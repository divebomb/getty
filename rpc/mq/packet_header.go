// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packet_header.proto

package mq

import (
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net"
	"strconv"
	"strings"
)

import (
	_ "github.com/gogo/protobuf/gogoproto"
	"github.com/gogo/protobuf/proto"
)

type InstanceType int32

const (
	InstanceType_PRODUCER InstanceType = 0
	InstanceType_CONSUMER InstanceType = 1
)

var InstanceType_name = map[int32]string{
	0: "PRODUCER",
	1: "CONSUMER",
}

var InstanceType_value = map[string]int32{
	"PRODUCER": 0,
	"CONSUMER": 1,
}

func (x InstanceType) Enum() *InstanceType {
	p := new(InstanceType)
	*p = x
	return p
}

func (x InstanceType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(InstanceType_name, int32(x))
}

func (x *InstanceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstanceType_value, data, "InstanceType")
	if err != nil {
		return err
	}
	*x = InstanceType(value)
	return nil
}

func (x InstanceType) String() string {
	s, ok := InstanceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type ConsumerType int32

const (
	ConsumerType_PUSH        ConsumerType = 0
	ConsumerType_AUTO_PULL   ConsumerType = 1
	ConsumerType_DIRECT_PULL ConsumerType = 2
)

var ConsumerType_name = map[int32]string{
	0: "PUSH",
	1: "AUTO_PULL",
	2: "DIRECT_PULL",
}

var ConsumerType_value = map[string]int32{
	"PUSH":        0,
	"AUTO_PULL":   1,
	"DIRECT_PULL": 2,
}

func (x ConsumerType) Enum() *ConsumerType {
	p := new(ConsumerType)
	*p = x
	return p
}

func (x ConsumerType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ConsumerType_name, int32(x))
}

func (x *ConsumerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConsumerType_value, data, "ConsumerType")
	if err != nil {
		return err
	}
	*x = ConsumerType(value)
	return nil
}

func (x ConsumerType) String() string {
	s, ok := ConsumerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type ConsumingMode int32

const (
	ConsumingMode_CLUSTERING   ConsumingMode = 0
	ConsumingMode_BROADCASTING ConsumingMode = 1
)

var ConsumingMode_name = map[int32]string{
	0: "CLUSTERING",
	1: "BROADCASTING",
}

var ConsumingMode_value = map[string]int32{
	"CLUSTERING":   0,
	"BROADCASTING": 1,
}

func (x ConsumingMode) Enum() *ConsumingMode {
	p := new(ConsumingMode)
	*p = x
	return p
}

func (x ConsumingMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ConsumingMode_name, int32(x))
}

func (x *ConsumingMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConsumingMode_value, data, "ConsumingMode")
	if err != nil {
		return err
	}
	*x = ConsumingMode(value)
	return nil
}

func (x ConsumingMode) String() string {
	s, ok := ConsumingMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type StartingPoint int32

const (
	StartingPoint_LAST_OFFSET  StartingPoint = 0
	StartingPoint_FIRST_OFFSET StartingPoint = 1
)

var StartingPoint_name = map[int32]string{
	0: "LAST_OFFSET",
	1: "FIRST_OFFSET",
}

var StartingPoint_value = map[string]int32{
	"LAST_OFFSET":  0,
	"FIRST_OFFSET": 1,
}

func (x StartingPoint) Enum() *StartingPoint {
	p := new(StartingPoint)
	*p = x
	return p
}

func (x StartingPoint) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(StartingPoint_name, int32(x))
}

func (x *StartingPoint) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StartingPoint_value, data, "StartingPoint")
	if err != nil {
		return err
	}
	*x = StartingPoint(value)
	return nil
}

func (x StartingPoint) String() string {
	s, ok := StartingPoint_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type TopicRouteMode int32

const (
	TopicRouteMode_DEFAULT               TopicRouteMode = 0
	TopicRouteMode_GLOBAL_QUEUE_ORDERING TopicRouteMode = 1
)

var TopicRouteMode_name = map[int32]string{
	0: "DEFAULT",
	1: "GLOBAL_QUEUE_ORDERING",
}

var TopicRouteMode_value = map[string]int32{
	"DEFAULT":               0,
	"GLOBAL_QUEUE_ORDERING": 1,
}

func (x TopicRouteMode) Enum() *TopicRouteMode {
	p := new(TopicRouteMode)
	*p = x
	return p
}

func (x TopicRouteMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TopicRouteMode_name, int32(x))
}

func (x *TopicRouteMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TopicRouteMode_value, data, "TopicRouteMode")
	if err != nil {
		return err
	}
	*x = TopicRouteMode(value)
	return nil
}

func (x TopicRouteMode) String() string {
	s, ok := TopicRouteMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type GetOffsetType int32

const (
	GetOffsetType_MIN GetOffsetType = 0
	GetOffsetType_MAX GetOffsetType = 1
)

var GetOffsetType_name = map[int32]string{
	0: "MIN",
	1: "MAX",
}

var GetOffsetType_value = map[string]int32{
	"MIN": 0,
	"MAX": 1,
}

func (x GetOffsetType) Enum() *GetOffsetType {
	p := new(GetOffsetType)
	*p = x
	return p
}

func (x GetOffsetType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(GetOffsetType_name, int32(x))
}

func (x *GetOffsetType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetOffsetType_value, data, "GetOffsetType")
	if err != nil {
		return err
	}
	*x = GetOffsetType(value)
	return nil
}

func (x GetOffsetType) String() string {
	s, ok := GetOffsetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type SerializationType int32

const (
	SerializationType_JSON SerializationType = 0
	SerializationType_AVRO SerializationType = 1
)

var SerializationType_name = map[int32]string{
	0: "JSON",
	1: "AVRO",
}

var SerializationType_value = map[string]int32{
	"JSON": 0,
	"AVRO": 1,
}

func (x SerializationType) Enum() *SerializationType {
	p := new(SerializationType)
	*p = x
	return p
}

func (x SerializationType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(SerializationType_name, int32(x))
}

func (x *SerializationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SerializationType_value, data, "SerializationType")
	if err != nil {
		return err
	}
	*x = SerializationType(value)
	return nil
}
func (x SerializationType) String() string {
	s, ok := SerializationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type SchemaCompatibilityStrategy int32

const (
	//*
	// Always incompatible
	SchemaCompatibilityStrategy_NONE SchemaCompatibilityStrategy = 0
	//*
	// Messages written by a new schema can be read by an old schema
	SchemaCompatibilityStrategy_BACKWARD SchemaCompatibilityStrategy = 1
	//*
	// Messages written by an old schema can be read be a new schema
	SchemaCompatibilityStrategy_FORWARD SchemaCompatibilityStrategy = 2
	//*
	// Equivalent to both FORWARD and BACKWARD
	SchemaCompatibilityStrategy_FULL SchemaCompatibilityStrategy = 3
)

var SchemaCompatibilityStrategy_name = map[int32]string{
	0: "NONE",
	1: "BACKWARD",
	2: "FORWARD",
	3: "FULL",
}

var SchemaCompatibilityStrategy_value = map[string]int32{
	"NONE":     0,
	"BACKWARD": 1,
	"FORWARD":  2,
	"FULL":     3,
}

func (x SchemaCompatibilityStrategy) Enum() *SchemaCompatibilityStrategy {
	p := new(SchemaCompatibilityStrategy)
	*p = x
	return p
}

func (x SchemaCompatibilityStrategy) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(SchemaCompatibilityStrategy_name, int32(x))
}

func (x *SchemaCompatibilityStrategy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchemaCompatibilityStrategy_value, data, "SchemaCompatibilityStrategy")
	if err != nil {
		return err
	}
	*x = SchemaCompatibilityStrategy(value)
	return nil
}

func (x SchemaCompatibilityStrategy) String() string {
	s, ok := SchemaCompatibilityStrategy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type SendState int32

const (
	//*
	// send msg success
	SendState_SUCCESS SendState = 0
	//*
	// send msg timeout
	SendState_TIMEOUT SendState = 1
	//*
	// connect error
	SendState_CONNECT_EXCEPTION SendState = 2
	//*
	// Redirect to new queue view
	SendState_REDIRECT SendState = 3
	//*
	// DFS queue is not ready
	SendState_QUEUE_UNREADY SendState = 4
	SendState_QUEUE_ERROR   SendState = 5
	//*
	// unknown reason exception occurred when send msg
	SendState_UNKNOWN_REASON          SendState = 6
	SendState_NO_PERMISSION           SendState = 7
	SendState_TOPIC_NOT_EXIST         SendState = 8
	SendState_TOPIC_DELAY_NOT_ALLOWED SendState = 9
	SendState_TIMER_MSG_NOT_ALLOWED   SendState = 10
	SendState_DLQ_MSG_RESULT          SendState = 11
	SendState_BROKER_MODE_ERROR       SendState = 12
	SendState_REQUEST_HEADER_ILLEGAL  SendState = 13
	SendState_MESSAGE_ILLEGAL         SendState = 14
)

var SendState_name = map[int32]string{
	0:  "SUCCESS",
	1:  "TIMEOUT",
	2:  "CONNECT_EXCEPTION",
	3:  "REDIRECT",
	4:  "QUEUE_UNREADY",
	5:  "QUEUE_ERROR",
	6:  "UNKNOWN_REASON",
	7:  "NO_PERMISSION",
	8:  "TOPIC_NOT_EXIST",
	9:  "TOPIC_DELAY_NOT_ALLOWED",
	10: "TIMER_MSG_NOT_ALLOWED",
	11: "DLQ_MSG_RESULT",
	12: "BROKER_MODE_ERROR",
	13: "REQUEST_HEADER_ILLEGAL",
	14: "MESSAGE_ILLEGAL",
}

var SendState_value = map[string]int32{
	"SUCCESS":                 0,
	"TIMEOUT":                 1,
	"CONNECT_EXCEPTION":       2,
	"REDIRECT":                3,
	"QUEUE_UNREADY":           4,
	"QUEUE_ERROR":             5,
	"UNKNOWN_REASON":          6,
	"NO_PERMISSION":           7,
	"TOPIC_NOT_EXIST":         8,
	"TOPIC_DELAY_NOT_ALLOWED": 9,
	"TIMER_MSG_NOT_ALLOWED":   10,
	"DLQ_MSG_RESULT":          11,
	"BROKER_MODE_ERROR":       12,
	"REQUEST_HEADER_ILLEGAL":  13,
	"MESSAGE_ILLEGAL":         14,
}

func (x SendState) Enum() *SendState {
	p := new(SendState)
	*p = x
	return p
}

func (x SendState) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(SendState_name, int32(x))
}

func (x *SendState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SendState_value, data, "SendState")
	if err != nil {
		return err
	}
	*x = SendState(value)
	return nil
}

func (x SendState) String() string {
	s, ok := SendState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type PermName int32

const (
	PermName_PERM_DEFAULT PermName = 0
	//* 可执行
	PermName_PERM_INHERIT PermName = 1
	//* 可写
	PermName_PERM_WRITE PermName = 2
	//* 可读
	PermName_PERM_READ PermName = 4
	//* 可读可写
	PermName_PERM_READ_AND_WRITE PermName = 6
)

var PermName_name = map[int32]string{
	0: "PERM_DEFAULT",
	1: "PERM_INHERIT",
	2: "PERM_WRITE",
	4: "PERM_READ",
	6: "PERM_READ_AND_WRITE",
}

var PermName_value = map[string]int32{
	"PERM_DEFAULT":        0,
	"PERM_INHERIT":        1,
	"PERM_WRITE":          2,
	"PERM_READ":           4,
	"PERM_READ_AND_WRITE": 6,
}

func (x PermName) Enum() *PermName {
	p := new(PermName)
	*p = x
	return p
}

func (x PermName) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(PermName_name, int32(x))
}

func (x *PermName) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PermName_value, data, "PermName")
	if err != nil {
		return err
	}
	*x = PermName(value)
	return nil
}

func (x PermName) String() string {
	s, ok := PermName_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type MessageStateEnum int32

const (
	MessageStateEnum_WAITING   MessageStateEnum = 0
	MessageStateEnum_TRIGGERED MessageStateEnum = 1
	MessageStateEnum_NOT_EXIST MessageStateEnum = 2
	MessageStateEnum_NOT_SURE  MessageStateEnum = 3
)

var MessageStateEnum_name = map[int32]string{
	0: "WAITING",
	1: "TRIGGERED",
	2: "NOT_EXIST",
	3: "NOT_SURE",
}

var MessageStateEnum_value = map[string]int32{
	"WAITING":   0,
	"TRIGGERED": 1,
	"NOT_EXIST": 2,
	"NOT_SURE":  3,
}

func (x MessageStateEnum) Enum() *MessageStateEnum {
	p := new(MessageStateEnum)
	*p = x
	return p
}

func (x MessageStateEnum) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MessageStateEnum_name, int32(x))
}

func (x *MessageStateEnum) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageStateEnum_value, data, "MessageStateEnum")
	if err != nil {
		return err
	}
	*x = MessageStateEnum(value)
	return nil
}

func (x MessageStateEnum) String() string {
	s, ok := MessageStateEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type RequestCommandCode int32

const (
	RequestCommandCode_CLIENT_REGISTER    RequestCommandCode = 1000
	RequestCommandCode_CLIENT_UNREGISTER  RequestCommandCode = 1001
	RequestCommandCode_CLIENT_HEARTBEAT   RequestCommandCode = 1002
	RequestCommandCode_GET_TOPIC_METADATA RequestCommandCode = 1003
	//* get queue offset: min offset, max offset
	RequestCommandCode_GET_OFFSET RequestCommandCode = 1004
	//* query consuming offset
	RequestCommandCode_QUERY_OFFSET RequestCommandCode = 1005
	//* save consuming offset
	RequestCommandCode_SAVE_OFFSET RequestCommandCode = 1006
	//* reset offset
	RequestCommandCode_RESET_OFFSET                 RequestCommandCode = 1011
	RequestCommandCode_GET_CONSUMERS                RequestCommandCode = 1007
	RequestCommandCode_QUERY_OFFSET_BY_TIMESTAMP    RequestCommandCode = 1008
	RequestCommandCode_CONSUMER_LIST_CHANGE         RequestCommandCode = 1009
	RequestCommandCode_GET_ASSIGNED_QUEUES          RequestCommandCode = 1012
	RequestCommandCode_SEND_MESSAGE                 RequestCommandCode = 2000
	RequestCommandCode_SUBMIT_TRANSACTIONAL_MESSAGE RequestCommandCode = 2001
	RequestCommandCode_CHECK_TRANSACTIONAL_MESSAGE  RequestCommandCode = 2002
	RequestCommandCode_SCHEDULE_MESSAGE             RequestCommandCode = 2003
	RequestCommandCode_SEND_BATCH_MESSAGE           RequestCommandCode = 2004
	RequestCommandCode_FETCH_MESSAGE                RequestCommandCode = 3000
	RequestCommandCode_DELIVERY_MESSAGE             RequestCommandCode = 3001
)

var RequestCommandCode_name = map[int32]string{
	1000: "CLIENT_REGISTER",
	1001: "CLIENT_UNREGISTER",
	1002: "CLIENT_HEARTBEAT",
	1003: "GET_TOPIC_METADATA",
	1004: "GET_OFFSET",
	1005: "QUERY_OFFSET",
	1006: "SAVE_OFFSET",
	1011: "RESET_OFFSET",
	1007: "GET_CONSUMERS",
	1008: "QUERY_OFFSET_BY_TIMESTAMP",
	1009: "CONSUMER_LIST_CHANGE",
	1012: "GET_ASSIGNED_QUEUES",
	2000: "SEND_MESSAGE",
	2001: "SUBMIT_TRANSACTIONAL_MESSAGE",
	2002: "CHECK_TRANSACTIONAL_MESSAGE",
	2003: "SCHEDULE_MESSAGE",
	2004: "SEND_BATCH_MESSAGE",
	3000: "FETCH_MESSAGE",
	3001: "DELIVERY_MESSAGE",
}

var RequestCommandCode_value = map[string]int32{
	"CLIENT_REGISTER":              1000,
	"CLIENT_UNREGISTER":            1001,
	"CLIENT_HEARTBEAT":             1002,
	"GET_TOPIC_METADATA":           1003,
	"GET_OFFSET":                   1004,
	"QUERY_OFFSET":                 1005,
	"SAVE_OFFSET":                  1006,
	"RESET_OFFSET":                 1011,
	"GET_CONSUMERS":                1007,
	"QUERY_OFFSET_BY_TIMESTAMP":    1008,
	"CONSUMER_LIST_CHANGE":         1009,
	"GET_ASSIGNED_QUEUES":          1012,
	"SEND_MESSAGE":                 2000,
	"SUBMIT_TRANSACTIONAL_MESSAGE": 2001,
	"CHECK_TRANSACTIONAL_MESSAGE":  2002,
	"SCHEDULE_MESSAGE":             2003,
	"SEND_BATCH_MESSAGE":           2004,
	"FETCH_MESSAGE":                3000,
	"DELIVERY_MESSAGE":             3001,
}

func (x RequestCommandCode) Enum() *RequestCommandCode {
	p := new(RequestCommandCode)
	*p = x
	return p
}

func (x RequestCommandCode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RequestCommandCode_name, int32(x))
}

func (x *RequestCommandCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RequestCommandCode_value, data, "RequestCommandCode")
	if err != nil {
		return err
	}
	*x = RequestCommandCode(value)
	return nil
}

func (x RequestCommandCode) String() string {
	s, ok := RequestCommandCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type ResponseCommandCode int32

const (
	// SUCCESS  = 0;
	// TIMEOUT  = 1;
	ResponseCommandCode_CONNECTION_ERROR ResponseCommandCode = 2
	ResponseCommandCode_UN_SUPPORT       ResponseCommandCode = 3
	ResponseCommandCode_HANDLE_FAIL      ResponseCommandCode = 4
	ResponseCommandCode_UNKNOWN_ERROR    ResponseCommandCode = 100
)

var ResponseCommandCode_name = map[int32]string{
	2:   "CONNECTION_ERROR",
	3:   "UN_SUPPORT",
	4:   "HANDLE_FAIL",
	100: "UNKNOWN_ERROR",
}

var ResponseCommandCode_value = map[string]int32{
	"CONNECTION_ERROR": 2,
	"UN_SUPPORT":       3,
	"HANDLE_FAIL":      4,
	"UNKNOWN_ERROR":    100,
}

func (x ResponseCommandCode) Enum() *ResponseCommandCode {
	p := new(ResponseCommandCode)
	*p = x
	return p
}

func (x ResponseCommandCode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ResponseCommandCode_name, int32(x))
}

func (x *ResponseCommandCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResponseCommandCode_value, data, "ResponseCommandCode")
	if err != nil {
		return err
	}
	*x = ResponseCommandCode(value)
	return nil
}

func (x ResponseCommandCode) String() string {
	s, ok := ResponseCommandCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type DefaultPullResult_PullState int32

const (
	//*
	// Pull message success(get the message)
	DefaultPullResult_SUCCESS DefaultPullResult_PullState = 0
	//*
	// no new message in queue
	DefaultPullResult_NO_NEW_MESSAGE DefaultPullResult_PullState = 1
	//*
	// has message but no matched
	DefaultPullResult_NO_MATCHED_MESSAGE DefaultPullResult_PullState = 2
	//*
	// try get the message from illegal offset
	DefaultPullResult_ILLEGAL_OFFSET DefaultPullResult_PullState = 3
	//*
	// redirect to a new message queue view; suggest to retry later
	DefaultPullResult_REDIRECT DefaultPullResult_PullState = 4
	//*
	// queue of DFS mode is unready; suggest to retry later
	DefaultPullResult_QUEUE_UNREADY DefaultPullResult_PullState = 5
	//*
	// topic does not exist
	DefaultPullResult_TOPIC_NOT_EXIST DefaultPullResult_PullState = 6
	//*
	// subscription does not exist
	DefaultPullResult_SUBSCRIPTION_NOT_EXIST DefaultPullResult_PullState = 7
	//*
	// subscription group does not exist
	DefaultPullResult_SUBSCRIPTION_GROUP_NOT_EXIST DefaultPullResult_PullState = 8
	//*
	// no permission
	DefaultPullResult_NO_PERMISSION DefaultPullResult_PullState = 9
	//*
	// unknown error
	DefaultPullResult_UNKNOWN_ERROR DefaultPullResult_PullState = 10
)

var DefaultPullResult_PullState_name = map[int32]string{
	0:  "SUCCESS",
	1:  "NO_NEW_MESSAGE",
	2:  "NO_MATCHED_MESSAGE",
	3:  "ILLEGAL_OFFSET",
	4:  "REDIRECT",
	5:  "QUEUE_UNREADY",
	6:  "TOPIC_NOT_EXIST",
	7:  "SUBSCRIPTION_NOT_EXIST",
	8:  "SUBSCRIPTION_GROUP_NOT_EXIST",
	9:  "NO_PERMISSION",
	10: "UNKNOWN_ERROR",
}

var DefaultPullResult_PullState_value = map[string]int32{
	"SUCCESS":                      0,
	"NO_NEW_MESSAGE":               1,
	"NO_MATCHED_MESSAGE":           2,
	"ILLEGAL_OFFSET":               3,
	"REDIRECT":                     4,
	"QUEUE_UNREADY":                5,
	"TOPIC_NOT_EXIST":              6,
	"SUBSCRIPTION_NOT_EXIST":       7,
	"SUBSCRIPTION_GROUP_NOT_EXIST": 8,
	"NO_PERMISSION":                9,
	"UNKNOWN_ERROR":                10,
}

func (x DefaultPullResult_PullState) Enum() *DefaultPullResult_PullState {
	p := new(DefaultPullResult_PullState)
	*p = x
	return p
}

func (x DefaultPullResult_PullState) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(DefaultPullResult_PullState_name, int32(x))
}

func (x *DefaultPullResult_PullState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DefaultPullResult_PullState_value, data, "DefaultPullResult_PullState")
	if err != nil {
		return err
	}
	*x = DefaultPullResult_PullState(value)
	return nil
}

type ReadMessageResponseHeader_PullState int32

const (
	//*
	// Pull message success(get the message)
	ReadMessageResponseHeader_SUCCESS ReadMessageResponseHeader_PullState = 0
	//*
	// no new message in queue
	ReadMessageResponseHeader_NO_NEW_MESSAGE ReadMessageResponseHeader_PullState = 1
	//*
	// has message but no matched
	ReadMessageResponseHeader_NO_MATCHED_MESSAGE ReadMessageResponseHeader_PullState = 2
	//*
	// try get the message from illegal offset
	ReadMessageResponseHeader_ILLEGAL_OFFSET ReadMessageResponseHeader_PullState = 3
	//*
	// redirect to a new message queue view; suggest to retry later
	ReadMessageResponseHeader_REDIRECT ReadMessageResponseHeader_PullState = 4
	//*
	// queue of DFS mode is unready; suggest to retry later
	ReadMessageResponseHeader_QUEUE_UNREADY ReadMessageResponseHeader_PullState = 5
	//*
	// topic does not exist
	ReadMessageResponseHeader_TOPIC_NOT_EXIST ReadMessageResponseHeader_PullState = 6
	//*
	// subscription does not exist
	ReadMessageResponseHeader_SUBSCRIPTION_NOT_EXIST ReadMessageResponseHeader_PullState = 7
	//*
	// subscription group does not exist
	ReadMessageResponseHeader_SUBSCRIPTION_GROUP_NOT_EXIST ReadMessageResponseHeader_PullState = 8
	//*
	// no permission
	ReadMessageResponseHeader_NO_PERMISSION ReadMessageResponseHeader_PullState = 9
	//*
	// unknown error
	ReadMessageResponseHeader_UNKNOWN_ERROR ReadMessageResponseHeader_PullState = 10
)

var ReadMessageResponseHeader_PullState_name = map[int32]string{
	0:  "SUCCESS",
	1:  "NO_NEW_MESSAGE",
	2:  "NO_MATCHED_MESSAGE",
	3:  "ILLEGAL_OFFSET",
	4:  "REDIRECT",
	5:  "QUEUE_UNREADY",
	6:  "TOPIC_NOT_EXIST",
	7:  "SUBSCRIPTION_NOT_EXIST",
	8:  "SUBSCRIPTION_GROUP_NOT_EXIST",
	9:  "NO_PERMISSION",
	10: "UNKNOWN_ERROR",
}

var ReadMessageResponseHeader_PullState_value = map[string]int32{
	"SUCCESS":                      0,
	"NO_NEW_MESSAGE":               1,
	"NO_MATCHED_MESSAGE":           2,
	"ILLEGAL_OFFSET":               3,
	"REDIRECT":                     4,
	"QUEUE_UNREADY":                5,
	"TOPIC_NOT_EXIST":              6,
	"SUBSCRIPTION_NOT_EXIST":       7,
	"SUBSCRIPTION_GROUP_NOT_EXIST": 8,
	"NO_PERMISSION":                9,
	"UNKNOWN_ERROR":                10,
}

func (x ReadMessageResponseHeader_PullState) Enum() *ReadMessageResponseHeader_PullState {
	p := new(ReadMessageResponseHeader_PullState)
	*p = x
	return p
}

func (x ReadMessageResponseHeader_PullState) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ReadMessageResponseHeader_PullState_name, int32(x))
}

func (x *ReadMessageResponseHeader_PullState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReadMessageResponseHeader_PullState_value, data, "ReadMessageResponseHeader_PullState")
	if err != nil {
		return err
	}
	*x = ReadMessageResponseHeader_PullState(value)
	return nil
}

func (x ReadMessageResponseHeader_PullState) String() string {
	s, ok := ReadMessageResponseHeader_PullState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type AbstractPacketHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	ClientId   string `protobuf:"bytes,2,opt,name=clientId" json:"clientId"`
}

type WriteMessageHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	QueueId    int32  `protobuf:"varint,2,opt,name=queueId" json:"queueId"`
	// optional string   address=3;
	Topic            string            `protobuf:"bytes,4,opt,name=topic" json:"topic"`
	Tag              string            `protobuf:"bytes,5,opt,name=tag" json:"tag"`
	DelaySeconds     int64             `protobuf:"varint,6,opt,name=delaySeconds" json:"delaySeconds"`
	BornTime         int64             `protobuf:"varint,7,opt,name=bornTime" json:"bornTime"`
	Producer         string            `protobuf:"bytes,8,opt,name=producer" json:"producer"`
	Properties       map[string]string `protobuf:"bytes,9,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemProperties map[string]string `protobuf:"bytes,10,rep,name=systemProperties" json:"systemProperties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ShardKey         string            `protobuf:"bytes,11,opt,name=shardKey" json:"shardKey"`
	ClientId         string            `protobuf:"bytes,12,opt,name=clientId" json:"clientId"`
}

type WriteBatchMessageHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	QueueId    int32  `protobuf:"varint,2,opt,name=queueId" json:"queueId"`
	// optional string   address=3;
	Topic               string            `protobuf:"bytes,4,opt,name=topic" json:"topic"`
	Tag                 string            `protobuf:"bytes,5,opt,name=tag" json:"tag"`
	DelaySeconds        int64             `protobuf:"varint,6,opt,name=delaySeconds" json:"delaySeconds"`
	BornTime            int64             `protobuf:"varint,7,opt,name=bornTime" json:"bornTime"`
	Producer            string            `protobuf:"bytes,8,opt,name=producer" json:"producer"`
	ShardKey            string            `protobuf:"bytes,9,opt,name=shardKey" json:"shardKey"`
	BatchSize           int32             `protobuf:"varint,10,opt,name=batchSize" json:"batchSize"`
	PropertiesMap       map[string]string `protobuf:"bytes,11,rep,name=propertiesMap" json:"propertiesMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemPropertiesMap map[string]string `protobuf:"bytes,12,rep,name=systemPropertiesMap" json:"systemPropertiesMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ClientId            string            `protobuf:"bytes,13,opt,name=clientId" json:"clientId"`
}

type MessageQueue struct {
	Id      int32  `protobuf:"varint,1,opt,name=id" json:"id"`
	Topic   string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	Address string `protobuf:"bytes,3,opt,name=address" json:"address"`
	Broker  string `protobuf:"bytes,4,opt,name=broker" json:"broker"`
	// MessageQueuePermissionHelper.PERM_READ | MessageQueuePermissionHelper.PERM_WRITE
	Permission       int32 `protobuf:"varint,5,opt,name=permission" json:"permission"`
	GlobalFixedQueue bool  `protobuf:"varint,6,opt,name=globalFixedQueue" json:"globalFixedQueue"`
}

type CheckTransactionalMessageHeader struct {
	InstanceId       string            `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Queue            MessageQueue      `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	Offset           int64             `protobuf:"varint,3,opt,name=offset" json:"offset"`
	MessageId        string            `protobuf:"bytes,4,opt,name=messageId" json:"messageId"`
	MessageSize      int32             `protobuf:"varint,5,opt,name=messageSize" json:"messageSize"`
	TransactionId    string            `protobuf:"bytes,6,opt,name=transactionId" json:"transactionId"`
	StoreTime        int64             `protobuf:"varint,7,opt,name=storeTime" json:"storeTime"`
	Tag              string            `protobuf:"bytes,8,opt,name=tag" json:"tag"`
	DelaySeconds     int64             `protobuf:"varint,9,opt,name=delaySeconds" json:"delaySeconds"`
	BornTime         int64             `protobuf:"varint,10,opt,name=bornTime" json:"bornTime"`
	Producer         string            `protobuf:"bytes,11,opt,name=producer" json:"producer"`
	Properties       map[string]string `protobuf:"bytes,12,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemProperties map[string]string `protobuf:"bytes,13,rep,name=systemProperties" json:"systemProperties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ClientId         string            `protobuf:"bytes,14,opt,name=clientId" json:"clientId"`
}

type InstanceInfo struct {
	Type           InstanceType   `protobuf:"varint,1,opt,name=type,enum=InstanceType" json:"type"`
	Group          string         `protobuf:"bytes,2,opt,name=group" json:"group"`
	Id             string         `protobuf:"bytes,3,opt,name=id" json:"id"`
	Version        string         `protobuf:"bytes,4,opt,name=version" json:"version"`
	ConsumerType   ConsumerType   `protobuf:"varint,5,opt,name=consumerType,enum=ConsumerType" json:"consumerType"`
	ConsumingMode  ConsumingMode  `protobuf:"varint,6,opt,name=consumingMode,enum=ConsumingMode" json:"consumingMode"`
	StartingPoint  StartingPoint  `protobuf:"varint,7,opt,name=startingPoint,enum=StartingPoint" json:"startingPoint"`
	Subscribed     []string       `protobuf:"bytes,8,rep,name=subscribed" json:"subscribed,omitempty"`
	AppName        string         `protobuf:"bytes,9,opt,name=appName" json:"appName"`
	TopicRouteMode TopicRouteMode `protobuf:"varint,10,opt,name=topicRouteMode,enum=TopicRouteMode" json:"topicRouteMode"`
}

type ClientHeartbeatHeader struct {
	InstanceId   string       `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	InstanceInfo InstanceInfo `protobuf:"bytes,2,opt,name=instanceInfo" json:"instanceInfo"`
	ClientId     string       `protobuf:"bytes,3,opt,name=clientId" json:"clientId"`
}

type SubmitTransactionHeader struct {
	InstanceId    string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic         string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	Group         string `protobuf:"bytes,3,opt,name=group" json:"group"`
	Queue         int32  `protobuf:"varint,4,opt,name=queue" json:"queue"`
	TransactionId string `protobuf:"bytes,5,opt,name=transactionId" json:"transactionId"`
	MessageId     string `protobuf:"bytes,6,opt,name=messageId" json:"messageId"`
	MessageSize   int32  `protobuf:"varint,7,opt,name=messageSize" json:"messageSize"`
	StoreTime     int64  `protobuf:"varint,8,opt,name=storeTime" json:"storeTime"`
	//*
	// whether request is redirect from other broker
	RedirectRequest bool `protobuf:"varint,9,opt,name=redirectRequest" json:"redirectRequest"`
	Commit          bool `protobuf:"varint,10,opt,name=commit" json:"commit"`
	//*
	// false: submit transaction state by checker
	// true: submit transaction state by producer
	Passive  bool   `protobuf:"varint,11,opt,name=passive" json:"passive"`
	Address  string `protobuf:"bytes,12,opt,name=address" json:"address"`
	ClientId string `protobuf:"bytes,13,opt,name=clientId" json:"clientId"`
}

type SaveSingleOffsetHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32  `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Group      string `protobuf:"bytes,4,opt,name=group" json:"group"`
	Offset     int64  `protobuf:"varint,5,opt,name=offset" json:"offset"`
	Address    string `protobuf:"bytes,6,opt,name=address" json:"address"`
	ClientId   string `protobuf:"bytes,7,opt,name=clientId" json:"clientId"`
}

type QueryOffsetHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32  `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Group      string `protobuf:"bytes,4,opt,name=group" json:"group"`
	Address    string `protobuf:"bytes,5,opt,name=address" json:"address"`
	ClientId   string `protobuf:"bytes,6,opt,name=clientId" json:"clientId"`
}

type QueryOffsetResponseHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32  `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Group      string `protobuf:"bytes,4,opt,name=group" json:"group"`
	Offset     int64  `protobuf:"varint,5,opt,name=offset" json:"offset"`
	ClientId   string `protobuf:"bytes,6,opt,name=clientId" json:"clientId"`
}

type QueryOffsetByTimestampHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32  `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Timestamp  int64  `protobuf:"varint,4,opt,name=timestamp" json:"timestamp"`
	Address    string `protobuf:"bytes,5,opt,name=address" json:"address"`
	ClientId   string `protobuf:"bytes,6,opt,name=clientId" json:"clientId"`
}

type QueryOffsetByTimestampResponseHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32  `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Offset     int64  `protobuf:"varint,4,opt,name=offset" json:"offset"`
	ClientId   string `protobuf:"bytes,5,opt,name=clientId" json:"clientId"`
}

type GetTopicMetadataHeader struct {
	InstanceId string         `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string         `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	Mode       TopicRouteMode `protobuf:"varint,3,opt,name=mode,enum=TopicRouteMode" json:"mode"`
	Group      string         `protobuf:"bytes,4,opt,name=group" json:"group"`
	ClientId   string         `protobuf:"bytes,5,opt,name=clientId" json:"clientId"`
}

type GetOffsetHeader struct {
	InstanceId string        `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string        `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32         `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Type       GetOffsetType `protobuf:"varint,4,opt,name=type,enum=GetOffsetType" json:"type"`
	Address    string        `protobuf:"bytes,5,opt,name=address" json:"address"`
	ClientId   string        `protobuf:"bytes,6,opt,name=clientId" json:"clientId"`
}

type GetOffsetResponseHeader struct {
	InstanceId string        `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string        `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	QueueId    int32         `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	Type       GetOffsetType `protobuf:"varint,4,opt,name=type,enum=GetOffsetType" json:"type"`
	Offset     int64         `protobuf:"varint,5,opt,name=offset" json:"offset"`
	ClientId   string        `protobuf:"bytes,6,opt,name=clientId" json:"clientId"`
}

type IndexInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Type string `protobuf:"bytes,2,opt,name=type" json:"type"`
}

type SchemaData struct {
	Id                int32                       `protobuf:"varint,1,opt,name=id" json:"id"`
	Version           int32                       `protobuf:"varint,2,opt,name=version" json:"version"`
	SerializationType SerializationType           `protobuf:"varint,3,opt,name=serializationType,enum=SerializationType" json:"serializationType"`
	Compatibility     SchemaCompatibilityStrategy `protobuf:"varint,4,opt,name=compatibility,enum=SchemaCompatibilityStrategy" json:"compatibility"`
	InstanceId        string                      `protobuf:"bytes,5,opt,name=instanceId" json:"instanceId"`
	Cluster           string                      `protobuf:"bytes,6,opt,name=cluster" json:"cluster"`
	Topic             string                      `protobuf:"bytes,7,opt,name=topic" json:"topic"`
	Tag               string                      `protobuf:"bytes,8,opt,name=tag" json:"tag"`
	Indexes           []IndexInfo                 `protobuf:"bytes,9,rep,name=indexes" json:"indexes"`
	//*
	// content is the json form of {@link org.apache.avro.Schema}
	Content    string            `protobuf:"bytes,10,opt,name=content" json:"content"`
	Properties map[string]string `protobuf:"bytes,11,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

type SchemaId struct {
	Id      int32 `protobuf:"varint,1,opt,name=id" json:"id"`
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version"`
}

type FlexibleMessage struct {
	// Message begin
	Topic            string            `protobuf:"bytes,1,opt,name=topic" json:"topic"`
	Tag              string            `protobuf:"bytes,2,opt,name=tag" json:"tag"`
	DelaySeconds     int64             `protobuf:"varint,3,opt,name=delaySeconds" json:"delaySeconds"`
	ShardKey         string            `protobuf:"bytes,4,opt,name=shardKey" json:"shardKey"`
	SchemaId         SchemaId          `protobuf:"bytes,5,opt,name=schemaId" json:"schemaId"`
	Properties       map[string]string `protobuf:"bytes,6,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Content          []byte            `protobuf:"bytes,7,opt,name=content" json:"content"`
	BornTime         int64             `protobuf:"varint,8,opt,name=bornTime" json:"bornTime"`
	Producer         string            `protobuf:"bytes,9,opt,name=producer" json:"producer"`
	SystemProperties map[string]string `protobuf:"bytes,10,rep,name=systemProperties" json:"systemProperties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

type FlexibleMessageAndContext struct {
	FlexibleMessage
	MessageContext
	MessageAndContext
}

var (
	ENTRY_SPLIT          = string([]byte{0x01})
	KEY_VALUE_SPLIT      = string([]byte{0x02})
	PROPERTY_TAGS        = "TAGS"
	REAL_MSG_ID          = "RMID"
	ANTQ_ENTITY_PROPERTY = "antq_entity_property"
)

func toMap(properties string) map[string]string {
	if len(properties) == 0 {
		return nil
	}

	m := make(map[string]string, 4)
	kvs := strings.Split(properties, ENTRY_SPLIT)

	for _, kv := range kvs {
		arr := strings.Split(kv, KEY_VALUE_SPLIT)
		if 2 == len(arr) {
			m[arr[0]] = arr[1]
		}
	}

	return m
}

func (m *FlexibleMessageAndContext) Decode(buffer []byte) (int, error) {
	bufferLen := len(buffer)

	// size
	pos := 0
	limit := 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got size", bufferLen, limit)
	}
	msgSize := int(binary.BigEndian.Uint32(buffer[pos:limit]))
	pos = limit

	if bufferLen < msgSize {
		return 0, fmt.Errorf("@buffer length %d < msgSize %d", bufferLen, msgSize)
	}

	// magic
	pos += 4

	// crc
	pos += 4

	// queueId
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got queueId", bufferLen, limit)
	}
	m.QueueId = int32(binary.BigEndian.Uint32(buffer[pos:limit]))
	pos = limit

	// queueOffset, 8
	limit = pos + 8
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got queueOffset", bufferLen, limit)
	}
	m.Offset = int64(binary.BigEndian.Uint64(buffer[pos:limit]))
	pos = limit

	// logOffset, 8
	limit = pos + 8
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got logOffset", bufferLen, limit)
	}
	m.LogOffset = int64(binary.BigEndian.Uint64(buffer[pos:limit]))
	pos = limit

	// sysFlag, 4
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got sysFlag", bufferLen, limit)
	}
	pos = limit

	// storeTime, 8
	limit = pos + 8
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got storeTime", bufferLen, limit)
	}
	// remark for fast
	// m.StoreTime = int64(binary.BigEndian.Uint64(buffer[pos:limit]))
	pos = limit

	// storeHost, 4
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got storeHost", bufferLen, limit)
	}
	// remark for fast
	storeIP := make(net.IP, 4)
	binary.BigEndian.PutUint32(storeIP, binary.BigEndian.Uint32(buffer[pos:limit]))
	m.StoreHost = storeIP.String()
	pos = limit

	// port, 4
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got port", bufferLen, limit)
	}
	// remark for fast
	m.StoreHost += ":" + strconv.Itoa(int(binary.BigEndian.Uint32(buffer[pos:limit])))
	pos = limit

	// consumeTimes, 4
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got consumeTimes", bufferLen, limit)
	}
	// remark for fast
	// m.DeliveryCount = int32(binary.BigEndian.Uint32(buffer[pos:limit]))
	pos = limit

	// topicLen, 1
	limit = pos + 1
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got topicLen", bufferLen, limit)
	}
	topicLen := int(buffer[pos])
	pos = limit

	// topic
	limit = pos + topicLen
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got topic", bufferLen, limit)
	}
	// remark for fast
	m.Topic = string(buffer[pos:limit])
	pos = limit

	// propertiesLength, 2
	limit = pos + 2
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got propertiesLength", bufferLen, limit)
	}
	propertiesLength := int32(binary.BigEndian.Uint16(buffer[pos:limit]))
	pos = limit

	// properties
	limit = pos + int(propertiesLength)
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got properties", bufferLen, limit)
	}
	m.Properties = toMap(string(buffer[pos:limit]))
	if len(m.Properties) != 0 {
		m.Tag = m.Properties[PROPERTY_TAGS]
	}
	pos = limit

	// contextLength, 2
	limit = pos + 2
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got contextLength", bufferLen, limit)
	}
	contextLength := int32(binary.BigEndian.Uint16(buffer[pos:limit]))
	pos = limit

	// systemProperties
	limit = pos + int(contextLength)
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got contextLength", bufferLen, limit)
	}
	m.SystemProperties = toMap(string(buffer[pos:limit]))
	if len(m.SystemProperties) != 0 {
		if len(m.Tag) == 0 {
			m.Tag = m.SystemProperties[PROPERTY_TAGS]
			m.MessageId = m.SystemProperties[REAL_MSG_ID]
		}

		//if len(m.Tag) == 0 {
		//	jsonStr := m.SystemProperties[ANTQ_ENTITY_PROPERTY]
		//	if len(jsonStr) != 0 {
		//		var entities map[string]interface{}
		//		err := json.Unmarshal([]byte(jsonStr), &entities)
		//		if err == nil {
		//			m.Tag = entities["messageType"].(string)
		//			m.MessageId = entities["messageId"].(string)
		//		}
		//	}
		//}
	}
	pos = limit

	// bodyLen, 4
	limit = pos + 4
	if bufferLen < limit {
		return 0, fmt.Errorf("bufferLen %d < %d, can not got bodyLen", bufferLen, limit)
	}
	bodyLen := int(binary.BigEndian.Uint32(buffer[pos:limit]))
	pos = limit

	// body
	limit = pos + bodyLen
	if msgSize < limit {
		return 0, fmt.Errorf("msgSize %d < limit %d", msgSize, limit)
	}
	// remark for fast
	// m.Content = append(m.Content, buffer[pos:limit]...)

	return int(msgSize), nil
}

const (
	/** 消息ID长度 */
	MSG_ID_LENGTH = 8 + 8 + 4
	/** DFS模式下的消息ID长度 */
	DFS_MSG_ID_LENGTH = 1 + 8 + 8 + 4
	/** DFS模式的MsgId以Integer.MAX_VALUE开头 */
	MessageIdMagicVersion = byte(127)
)

func (m *FlexibleMessageAndContext) GetMessageID(fixedQueue bool, topicId int) {
	if len(m.MessageId) != 0 {
		return
	}

	var (
		start, end int
		msgIDArray []byte
	)
	if fixedQueue {
		start = 0
		end = 0
		msgIDArray = make([]byte, DFS_MSG_ID_LENGTH)

		// magic version, 1
		end += 1
		msgIDArray[0] = MessageIdMagicVersion
		start = end

		// topicID == topic name hash code, 8
		end += 8
		binary.BigEndian.PutUint64(msgIDArray[start:end], uint64(topicId))
		start = end

		// offset, 8
		end += 8
		binary.BigEndian.PutUint64(msgIDArray[start:end], uint64(m.LogOffset))
		start = end

		// queueID, 4
		end += 4
		binary.BigEndian.PutUint32(msgIDArray[start:end], uint32(m.QueueId))

		m.MessageId = strings.ToUpper(hex.EncodeToString(msgIDArray[0:end]))
		return
	}

	start = 0
	end = 0
	msgIDArray = make([]byte, MSG_ID_LENGTH)

	// broker host, 8
	host, port, _ := net.SplitHostPort(m.StoreHost)
	if strings.HasPrefix(host, "/") {
		host = host[1:]
	}

	end += 4
	copy(msgIDArray[start:end], net.ParseIP(host).To4())
	start = end

	end += 4
	uPort, _ := strconv.Atoi(port)
	binary.BigEndian.PutUint32(msgIDArray[start:end], uint32(uPort))
	start = end

	// offset, 8
	end += 8
	binary.BigEndian.PutUint64(msgIDArray[start:end], uint64(m.LogOffset))
	start = end

	// queueID, 4
	end += 4
	binary.BigEndian.PutUint32(msgIDArray[start:end], uint32(m.QueueId))
	m.MessageId = strings.ToUpper(hex.EncodeToString(msgIDArray[0:end]))

	return
}

type MessageContext struct {
	MessageId     string     `protobuf:"bytes,1,opt,name=messageId" json:"messageId"`
	DeliveryCount int32      `protobuf:"varint,2,opt,name=deliveryCount" json:"deliveryCount"`
	QueueId       int32      `protobuf:"varint,3,opt,name=queueId" json:"queueId"`
	StoreHost     string     `protobuf:"bytes,4,opt,name=storeHost" json:"storeHost"`
	StoreTime     int64      `protobuf:"varint,5,opt,name=storeTime" json:"storeTime"`
	Offset        int64      `protobuf:"varint,6,opt,name=offset" json:"offset"`
	LogOffset     int64      `protobuf:"varint,7,opt,name=logOffset" json:"logOffset"`
	Schema        SchemaData `protobuf:"bytes,8,opt,name=schema" json:"schema"`
}

type MessageAndContext struct {
	Message *Message        `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	Context *MessageContext `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
}

type DefaultPullResult struct {
	State        DefaultPullResult_PullState `protobuf:"varint,1,opt,name=state,enum=DefaultPullResult_PullState" json:"state"`
	Messages     []*MessageAndContext        `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	MessageQueue *MessageQueue               `protobuf:"bytes,3,opt,name=messageQueue" json:"messageQueue,omitempty"`
	StartOffset  int64                       `protobuf:"varint,4,opt,name=startOffset" json:"startOffset"`
	NextOffset   int64                       `protobuf:"varint,5,opt,name=nextOffset" json:"nextOffset"`
	MinOffset    int64                       `protobuf:"varint,6,opt,name=minOffset" json:"minOffset"`
	MaxOffset    int64                       `protobuf:"varint,7,opt,name=maxOffset" json:"maxOffset"`
}

type DeliveryMessageHeader struct {
	InstanceId string          `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Message    FlexibleMessage `protobuf:"bytes,2,opt,name=message" json:"message"`
	Context    MessageContext  `protobuf:"bytes,3,opt,name=context" json:"context"`
	ClientId   string          `protobuf:"bytes,4,opt,name=clientId" json:"clientId"`
}

type ReadMessageHeader struct {
	InstanceId         string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic              string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	Queue              int32  `protobuf:"varint,3,opt,name=queue" json:"queue"`
	Group              string `protobuf:"bytes,4,opt,name=group" json:"group"`
	Start              int64  `protobuf:"varint,5,opt,name=start" json:"start"`
	Commit             int64  `protobuf:"varint,6,opt,name=commit" json:"commit"`
	Batch              int32  `protobuf:"varint,7,opt,name=batch" json:"batch"`
	DisableLongPolling bool   `protobuf:"varint,8,opt,name=disableLongPolling" json:"disableLongPolling"`
	Timeout            int64  `protobuf:"varint,9,opt,name=timeout" json:"timeout"`
	Address            string `protobuf:"bytes,10,opt,name=address" json:"address"`
	ClientId           string `protobuf:"bytes,11,opt,name=clientId" json:"clientId"`
}

type ReadMessageResponseHeader struct {
	InstanceId string                              `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	State      ReadMessageResponseHeader_PullState `protobuf:"varint,3,opt,name=state,enum=ReadMessageResponseHeader_PullState" json:"state"`
	NextOffset int64                               `protobuf:"varint,6,opt,name=nextOffset" json:"nextOffset"`
	MinOffset  int64                               `protobuf:"varint,7,opt,name=minOffset" json:"minOffset"`
	MaxOffset  int64                               `protobuf:"varint,8,opt,name=maxOffset" json:"maxOffset"`
	Remark     string                              `protobuf:"bytes,9,opt,name=remark" json:"remark"`
	ClientId   string                              `protobuf:"bytes,10,opt,name=clientId" json:"clientId"`
}

type GetConsumersHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Topic      string `protobuf:"bytes,2,opt,name=topic" json:"topic"`
	Group      string `protobuf:"bytes,3,opt,name=group" json:"group"`
	ClientId   string `protobuf:"bytes,4,opt,name=clientId" json:"clientId"`
}

type ConsumerListChangeHeader struct {
	// group
	Consumer string `protobuf:"bytes,1,opt,name=consumer" json:"consumer"`
	// empty
	ClientId string `protobuf:"bytes,2,opt,name=clientId" json:"clientId"`
}

type CommonResponseHeader struct {
	InstanceId string `protobuf:"bytes,1,opt,name=InstanceId" json:"InstanceId"`
	Message    string `protobuf:"bytes,2,opt,name=message" json:"message"`
	ClientId   string `protobuf:"bytes,3,opt,name=clientId" json:"clientId"`
}

type AbstractSendResult struct {
	MessageQueue MessageQueue `protobuf:"bytes,1,opt,name=messageQueue" json:"messageQueue"`
	State        SendState    `protobuf:"varint,2,opt,name=state,enum=SendState" json:"state"`
}

type Message struct {
	Topic        string            `protobuf:"bytes,1,opt,name=topic" json:"topic"`
	Tag          string            `protobuf:"bytes,2,opt,name=tag" json:"tag"`
	DelaySeconds int64             `protobuf:"varint,3,opt,name=delaySeconds" json:"delaySeconds"`
	ShardKey     string            `protobuf:"bytes,4,opt,name=shardKey" json:"shardKey"`
	EventTime    int64             `protobuf:"varint,5,opt,name=eventTime" json:"eventTime"`
	SchemaId     SchemaId          `protobuf:"bytes,6,opt,name=schemaId" json:"schemaId"`
	Properties   map[string]string `protobuf:"bytes,7,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Content      [][]byte          `protobuf:"bytes,8,rep,name=content" json:"content,omitempty"`
}

// com/alipay/mq/client/producer/AbstractProducer.java:doSend
type DefaultSendResult struct {
	MessageQueue MessageQueue `protobuf:"bytes,1,opt,name=messageQueue" json:"messageQueue"`
	State        SendState    `protobuf:"varint,2,opt,name=state,enum=SendState" json:"state"`
	Offset       int64        `protobuf:"varint,3,opt,name=offset" json:"offset"`
	MessageId    string       `protobuf:"bytes,4,opt,name=messageId" json:"messageId"`
	Messsage     Message      `protobuf:"bytes,5,opt,name=messsage" json:"messsage"`
}

// com/alipay/mq/client/producer/AbstractProducer.java:doSend
type DefaultSendBatchResult struct {
	MessageQueue MessageQueue `protobuf:"bytes,1,opt,name=messageQueue" json:"messageQueue"`
	State        SendState    `protobuf:"varint,2,opt,name=state,enum=SendState" json:"state"`
	BatchSize    int32        `protobuf:"varint,3,opt,name=batchSize" json:"batchSize"`
	Offsets      []int64      `protobuf:"varint,4,rep,name=offsets" json:"offsets,omitempty"`
	MessageIds   []string     `protobuf:"bytes,5,rep,name=messageIds" json:"messageIds,omitempty"`
	Messages     []Message    `protobuf:"bytes,6,rep,name=messages" json:"messages"`
}

type AbstractWriteResult struct {
	Queue       MessageQueue `protobuf:"bytes,1,opt,name=queue" json:"queue"`
	Timeout     int64        `protobuf:"varint,2,opt,name=timeout" json:"timeout"`
	MessageSize int32        `protobuf:"varint,3,opt,name=messageSize" json:"messageSize"`
	StoreTime   int64        `protobuf:"varint,4,opt,name=storeTime" json:"storeTime"`
	State       SendState    `protobuf:"varint,5,opt,name=state,enum=SendState" json:"state"`
}

type WriteResult struct {
	Queue         MessageQueue    `protobuf:"bytes,1,opt,name=queue" json:"queue"`
	Timeout       int64           `protobuf:"varint,2,opt,name=timeout" json:"timeout"`
	MessageSize   int32           `protobuf:"varint,3,opt,name=messageSize" json:"messageSize"`
	StoreTime     int64           `protobuf:"varint,4,opt,name=storeTime" json:"storeTime"`
	State         SendState       `protobuf:"varint,5,opt,name=state,enum=SendState" json:"state"`
	Message       FlexibleMessage `protobuf:"bytes,6,opt,name=message" json:"message"`
	Offset        int64           `protobuf:"varint,7,opt,name=offset" json:"offset"`
	MessageId     string          `protobuf:"bytes,8,opt,name=messageId" json:"messageId"`
	TransactionId string          `protobuf:"bytes,9,opt,name=transactionId" json:"transactionId"`
}

type BatchWriteResult struct {
	Queue          MessageQueue      `protobuf:"bytes,1,opt,name=queue" json:"queue"`
	Timeout        int64             `protobuf:"varint,2,opt,name=timeout" json:"timeout"`
	MessageSize    int32             `protobuf:"varint,3,opt,name=messageSize" json:"messageSize"`
	StoreTime      int64             `protobuf:"varint,4,opt,name=storeTime" json:"storeTime"`
	State          SendState         `protobuf:"varint,5,opt,name=state,enum=SendState" json:"state"`
	BatchSize      int32             `protobuf:"varint,6,opt,name=batchSize" json:"batchSize"`
	Messages       []FlexibleMessage `protobuf:"bytes,7,rep,name=messages" json:"messages"`
	Offsets        []int64           `protobuf:"varint,8,rep,name=offsets" json:"offsets,omitempty"`
	MessageIds     []string          `protobuf:"bytes,9,rep,name=messageIds" json:"messageIds,omitempty"`
	TransactionIds []string          `protobuf:"bytes,10,rep,name=transactionIds" json:"transactionIds,omitempty"`
}

type AbstractWriteMessageResponseHeader struct {
	QueueId   int32     `protobuf:"varint,1,opt,name=queueId" json:"queueId"`
	StoreTime int64     `protobuf:"varint,2,opt,name=storeTime" json:"storeTime"`
	State     SendState `protobuf:"varint,3,opt,name=state,enum=SendState" json:"state"`
	Remark    string    `protobuf:"bytes,4,opt,name=remark" json:"remark"`
	ClientId  string    `protobuf:"bytes,5,opt,name=clientId" json:"clientId"`
}

type WriteBatchMessageResponseHeader struct {
	QueueId        int32     `protobuf:"varint,1,opt,name=queueId" json:"queueId"`
	StoreTime      int64     `protobuf:"varint,2,opt,name=storeTime" json:"storeTime"`
	State          SendState `protobuf:"varint,3,opt,name=state,enum=SendState" json:"state"`
	Remark         string    `protobuf:"bytes,4,opt,name=remark" json:"remark"`
	BatchSize      int32     `protobuf:"varint,5,opt,name=batchSize" json:"batchSize"`
	Offsets        []int64   `protobuf:"varint,6,rep,name=offsets" json:"offsets,omitempty"`
	MessageIds     []string  `protobuf:"bytes,7,rep,name=messageIds" json:"messageIds,omitempty"`
	TransactionIds []string  `protobuf:"bytes,8,rep,name=transactionIds" json:"transactionIds,omitempty"`
}

type WriteMessageResponseHeader struct {
	QueueId       int32     `protobuf:"varint,1,opt,name=queueId" json:"queueId"`
	StoreTime     int64     `protobuf:"varint,2,opt,name=storeTime" json:"storeTime"`
	State         SendState `protobuf:"varint,3,opt,name=state,enum=SendState" json:"state"`
	Remark        string    `protobuf:"bytes,4,opt,name=remark" json:"remark"`
	Offset        int64     `protobuf:"varint,5,opt,name=offset" json:"offset"`
	MessageId     string    `protobuf:"bytes,6,opt,name=messageId" json:"messageId"`
	MessageSize   int32     `protobuf:"varint,7,opt,name=messageSize" json:"messageSize"`
	TransactionId string    `protobuf:"bytes,8,opt,name=transactionId" json:"transactionId"`
}

type Topic struct {
	Id         int32    `protobuf:"varint,1,opt,name=id" json:"id"`
	Name       string   `protobuf:"bytes,2,opt,name=name" json:"name"`
	FixedQueue bool     `protobuf:"varint,3,opt,name=fixedQueue" json:"fixedQueue"`
	Cluster    string   `protobuf:"bytes,4,opt,name=cluster" json:"cluster"`
	Perm       PermName `protobuf:"varint,5,opt,name=perm,enum=PermName" json:"perm"`
}

type TopicMetadata struct {
	Topic          Topic          `protobuf:"bytes,1,opt,name=topic" json:"topic"`
	Version        int64          `protobuf:"varint,2,opt,name=version" json:"version"`
	MessageQueues  []MessageQueue `protobuf:"bytes,3,rep,name=messageQueues" json:"messageQueues"`
	WritableQueues []MessageQueue `protobuf:"bytes,4,rep,name=writableQueues" json:"writableQueues"`
	ReadableQueues []MessageQueue `protobuf:"bytes,5,rep,name=readableQueues" json:"readableQueues"`
	WriteIndex     int64          `protobuf:"varint,6,opt,name=writeIndex" json:"writeIndex"`
	ReadIndex      int64          `protobuf:"varint,7,opt,name=readIndex" json:"readIndex"`
}

// Get assigned message queues from MOSN
type GetAssignedQueuesHeader struct {
	Topic         string        `protobuf:"bytes,1,opt,name=topic" json:"topic"`
	Group         string        `protobuf:"bytes,2,opt,name=group" json:"group"`
	ConsumerId    string        `protobuf:"bytes,3,opt,name=consumerId" json:"consumerId"`
	ConsumingMode ConsumingMode `protobuf:"varint,4,opt,name=consumingMode,enum=ConsumingMode" json:"consumingMode"`
	ClientId      string        `protobuf:"bytes,5,opt,name=clientId" json:"clientId"`
}

type ClientConfiguration struct {
	Shared bool `protobuf:"varint,1,opt,name=shared" json:"shared"`
	// 租户 ID
	InstanceId   string `protobuf:"bytes,2,opt,name=instanceId" json:"instanceId"`
	DomainPrefix string `protobuf:"bytes,3,opt,name=domainPrefix" json:"domainPrefix"`
	TargetDomain string `protobuf:"bytes,4,opt,name=targetDomain" json:"targetDomain"`
	AppName      string `protobuf:"bytes,5,opt,name=appName" json:"appName"`
	ZoneName     string `protobuf:"bytes,6,opt,name=zoneName" json:"zoneName"`
	EndPoint     string `protobuf:"bytes,7,opt,name=endPoint" json:"endPoint"`
	ProductName  string `protobuf:"bytes,8,opt,name=productName" json:"productName"`
}

func (c ClientConfiguration) String() string {
	confBytes, err := json.Marshal(&c)
	if err == nil {
		return string(confBytes)
	}

	return ""
}

type ScheduleMessageHeader struct {
	// broker address
	Address   string `protobuf:"bytes,1,opt,name=address" json:"address"`
	MessageId string `protobuf:"bytes,2,opt,name=messageId" json:"messageId"`
	Timestamp int64  `protobuf:"varint,3,opt,name=timestamp" json:"timestamp"`
	ClientId  string `protobuf:"bytes,4,opt,name=clientId" json:"clientId"`
}

type ScheduleMessageResponseHeader struct {
	OperationSuccess bool             `protobuf:"varint,1,opt,name=operationSuccess" json:"operationSuccess"`
	MessageState     MessageStateEnum `protobuf:"varint,2,opt,name=messageState,enum=MessageStateEnum" json:"messageState"`
	Remark           string           `protobuf:"bytes,3,opt,name=remark" json:"remark"`
	ClientId         string           `protobuf:"bytes,4,opt,name=clientId" json:"clientId"`
}

type ClientLogoutHeader struct {
	Group      string `protobuf:"bytes,1,opt,name=group" json:"group"`
	ClientId   string `protobuf:"bytes,2,opt,name=clientId" json:"clientId"`
	ClientType string `protobuf:"bytes,3,opt,name=clientType" json:"clientType"`
}

func (m *ClientLogoutHeader) Validate() bool {
	if len(m.Group) == 0 || len(m.ClientId) == 0 || len(m.ClientType) == 0 {
		return false
	}

	return true
}

type ClientLoginHeader struct {
	ID     string               `protobuf:"bytes,1,opt,name=ID" json:"ID"`
	Group  string               `protobuf:"bytes,2,opt,name=Group" json:"Group"`
	Config *ClientConfiguration `protobuf:"bytes,3,opt,name=Config" json:"Config,omitempty"`
}

func (m *ClientLoginHeader) Validate() bool {
	if len(m.ID) == 0 || len(m.Group) == 0 {
		return false
	}

	return true
}
